<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>HackStack Posts</title>
    <link>http://hackstack.org/x/blog</link>
    <description>OpenStack and other hackish things</description>
    <pubDate>Fri, 01 May 2015 03:02:27 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>OpenStackClient Is Three and Official</title>
      <link>http://hackstack.org/x/blog/2015/04/18/openstackclient-is-three-and-official</link>
      <pubDate>Sat, 18 Apr 2015 15:03:18 CDT</pubDate>
      <category><![CDATA[openstackclient]]></category>
      <guid isPermaLink="false">LEBXSZmpj9dKJ7in53liHud_d0k=</guid>
      <description>OpenStackClient Is Three and Official</description>
      <content:encoded><![CDATA[<div class="document">
<p>I was looking forward to writing a bit about OpenStackClient becoming the first
project added to OpenStack under the 'big yurt' <a class="footnote-reference" href="#id3" id="id1">[1]</a> governance model.  It was
even mostly written and set to publish right after the QA Code sprint article
when Nebula did what so many startups do, which is to abruptly cease to exist.
On April 1 no less.  So instead I'll rehash this as a note on OSC's third birthday,
based on the first repo commit.</p>
<div class="section" id="looking-backward">
<h1>Looking Backward</h1>
<p>I don't want to spend too much energy looking at where we have been, except to note
that a lot has happened since I shared a cab to SFO with Dolph Matthews and I floated the
idea of scrapping all of the OpenStack project CLIs and starting over.  He was
just receptive enough that I spent most of the flight home teasing out the basic
set of command actions and objects.  And he backed that up by later choosing to not
implement a CLI for the Identity v3 API but instead use OSC.</p>
<p>The rigorous <a class="reference external" href="http://docs.openstack.org/developer/python-openstackclient/commands.html">command structure</a> is what I consider the big win for OSC, having a
small set of common actions and a set of known objects that are manipulated with
those actions.  Define a common operation and then do that operation on <strong>EVERY</strong>
object the same way, even if that means a bunch of work under the hood because
the REST API doesn't work that way.</p>
<p>One now-forgotten tidbit here is that I designed the commands to look similar
to VMS's DCL command line set, in that the action preceeds the object.  One
complaint was that the objects needed to be pluralized on some actios, like <tt class="docutils literal">list</tt>,
because that's the proper English thing to do.  I ignored plurals completely,
although it does seem like we could have done it only with the list command.</p>
<p>It was at the Portland summit that I was persuaded to make the change when
someone who understands bash command completion better than I do (which is to say
'I never looked at it') mentioned that it would be <strong>much</strong> simpler if the
object came first.  OK, finally, a good technical reason to change so we did.
I think dhellmann said something like &quot;I expected that to be much harder&quot;
afterward.  I do change my mind, sometimes.</p>
</div>
<div class="section" id="looking-around-today">
<h1>Looking Around Today</h1>
<p>In the three years we have had just over 1000 commits from around 70 contributors.
I want to grow the team; we have a small band of regulars now with
a core review team of 4, having recently added Terry Howe, who has also spent
a significant amount of time working on the Python SDK.</p>
<p>We have a couple of interesting features brewing for the next significant release,
support for the <tt class="docutils literal"><span class="pre">os-client-config</span></tt> cloud configuration files and a client-side
caching that will significantly improve responsiveness in many instances. <a class="footnote-reference" href="#id4" id="id2">[2]</a></p>
<p>Another historical bit is that for most of its life, OSC was mostly a side project
for me.  I was able to eventually give it some real time along side DevStack and
the other things but it seems to be the kind of project that doesn't seem so
important until you really really need it now.</p>
<p>As I was talking to a lot of people over the last couple of weeks trying to find
my next professional home, it became clear to me how some people and organizations feel
about projects like OSC.  They're not sexy, not the sort of thing that 'sells'
customers on your cloud or your service or whatever.  There were a couple of companies
that totally did not view this as worth spending time on.  Fortunately for us all,
there are more companies that do think it is worth the time and I expect to be able
to give OSC and other client/app developer projects a significant part of my time
going forward.</p>
<p>When OSC was added as an official project, we also brought the <a class="reference external" href="http://git.openstack.org/cgit/openstack/os-client-config">os-client-config</a>
(from Stackforge) and <a class="reference external" href="http://git.openstack.org/cgit/openstack/cliff">cliff</a> (from Oslo) repos with it.  <tt class="docutils literal">Cliff</tt> was written
by Doug Hellmann specifically for OSC to manage the numerous command implementations
and give a solid basis for each of the actions.  I think it has worked out great
and been a great help in maintaining the consistency  in OSC so far.  It has also
been adopted by other projects, some outside of the OpenStack ecosystem.</p>
<p><tt class="docutils literal"><span class="pre">os-client-config</span></tt> (aka <tt class="docutils literal"><span class="pre">o-c-c</span></tt>) was originated by Monty Taylor to add client-side
cloud configuration along with his <a class="reference external" href="http://git.openstack.org/cgit/openstack-infra/shade">shade</a> library.
BTW, if you ever want to see what the challenges of using multiple clouds in the
same project, have a look at <tt class="docutils literal">shade</tt>.  In an ideal world it should not need to exist,
especially since it only talks to OpenStack clouds.</p>
<p>OSC will be using <tt class="docutils literal"><span class="pre">o-c-c</span></tt> to implement the same cloud configuration that will
make it <strong>simple</strong> to switch between cloud authentication configurations with a
single command line option.  And also to share public cloud configuration templates
without sharing authentication details for them.  I plan to follow up with details
on how to use this soon, watch this space.</p>
</div>
<div class="section" id="looking-ahead">
<h1>Looking Ahead</h1>
<p>Technically we still have a lot of work to do.  There are significant APIs
that are still not implemented (Network, Volume v2) and incomplete (Image v1 and
v2).  We need to speed up the load time, eliminate unnecessary dependencies,
and fix bugs.  Always fix bugs.</p>
<p>On a slightly longer scope, we will switch to use the OpenStack SDK when
it is ready, continue to better enable plugins to support upper layer services,
and most importantly, we MUST drive down the
number of dependencies required to install OSC and make it easy to use for
non-Python developers.  There needs to be a single file install that 'just works'.</p>
<p>I do still want to duplicate it all in Go.  My Go prototype is older than
OSC, actually...and is a single file install...</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Yeah, I know the usual term is <cite>big tent</cite>.  Every time I hear that I
think of a <cite>big top</cite> and I really don't want to be thought of as 'one of the
clowns in the big top'... even if it might be accurate...</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><strong>Update:</strong> Caching didn't make it.</td></tr>
</tbody>
</table>
</div>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>QA Code Sprint</title>
      <link>http://hackstack.org/x/blog/2015/03/30/qa-code-sprint</link>
      <pubDate>Mon, 30 Mar 2015 15:03:30 CDT</pubDate>
      <category><![CDATA[devstack]]></category>
      <guid isPermaLink="false">dhUlDjeuNEZ33lEFlpYjBJUlvvM=</guid>
      <description>QA Code Sprint</description>
      <content:encoded><![CDATA[<div class="document">
<p>Last week (Mar 25-27) a handful of OpenStack QA Team members gathered at
HP's Chelsea office to Get Some Code Written and Merged.  We had a small list
of priorities and some amazement at the amount of stuff the morning caterer
could fit into a single box. [Note to self: get a magic catering box to store
oversized project todo list]</p>
<p>I was focused primarily on DevStack although some discussion took place around
some future direction on Grenade plugins (see below).  Much actual work was
accomplished by others present in spite of Matt's attempts to feed us into
submission.  Dang, those short ribs were good...</p>
<div class="section" id="devstack">
<h1>DevStack</h1>
<p>There are two major priorities for DevStack: run services in virtual
environments and use Neutron as the default network stack.</p>
<div class="section" id="neutron">
<h2>Neutron</h2>
<p>Sean Collins (sc68cal) was present <a class="footnote-reference" href="#id4" id="id1">[1]</a> and is taking on most of the work to get
Neutron supported as the default.  We had given him some constraints to be the
default, being use of a single interface and using <tt class="docutils literal">linuxbridge</tt> rather than
Open vSwitch.  Other Sean had the <a class="reference external" href="https://review.openstack.org/168001">single interface work</a> mostly complete and
after one false start it was merged.</p>
<p>The selection of <tt class="docutils literal">linuxbridge</tt> seems to be a bit controversial but the thinking
goes like this: DevStack's default should be simple and not require a huge learning
curve.  The <tt class="docutils literal">linuxbridge</tt> configuration is an intermediate step between
<tt class="docutils literal"><span class="pre">nova-network</span></tt> and full-blown Neutron-with-OVS and is totally adequate for a
large number of use cases.  If it is not a valid use case, then we feel it should
be totally removed from Neutron.</p>
<p>Other Sean sent a <a class="reference external" href="https://review.openstack.org/168423">WIP review</a> into the gate to see just how badly <tt class="docutils literal">linuxbridge</tt>
is as it is not currently tested in the gate AT ALL! Unsurprisingly it has a
number of failures, but is not a total washout.</p>
<p>DevStack's Neutron code is in bad shape.  It has been continually updated by
many people who do not understand the Big Picture.  I blame myself for not
staying on top of this code and allowing it to diverge from the rest of DevStack's
style and implementation.  Other Sean found a number of inconsistencies in
variable names and uses as he tried to get the single interface work done and
we came to the inevitable conclusion that it was time to start over.</p>
<p><tt class="docutils literal">lib/neutron</tt> was renamed to <tt class="docutils literal"><span class="pre">lib/neutron-legacy</span></tt> in review <a class="reference external" href="https://review.openstack.org/#/c/167684">167684</a> and
I put together the first cut as a new <tt class="docutils literal">lib/neutron</tt> that takes a similar
form to the rest of DevStack in <a class="reference external" href="https://review.openstack.org/168438">168438</a>.  This is a stripped-down subset
that has a number of changes:</p>
<ul class="simple">
<li>Service names are renamed to <tt class="docutils literal"><span class="pre">neutron-api</span></tt>, <tt class="docutils literal"><span class="pre">neutron-agent</span></tt>, etc.</li>
<li>At this point, only the API service and basic agents are intended to be started.</li>
</ul>
<p>But what about the plugins?  What about the advanced services?  What about the vendors?
I can't do it all at once.  The first priority is to get a 'minimum viable
Neutron' configuration to use as the default.  The old code was renamed not
removed, and exactly zero of the configuration variables and service names have
changed.  Nothing should be directly importing <tt class="docutils literal">lib/neutron*</tt> so that change
is handled in DevStack and Grenade already.  After we have working <tt class="docutils literal">linuxbridge</tt>
and <tt class="docutils literal">ovs</tt> configurations we can look at what else needs to be included.</p>
<p>The advanced services should be implemented as plugins in the same manner that
we are doing with other layer 3 and higher services.  Vendor plugins will be
removed from the tree when the legacy code is removed and should also be moved
to out-of-tree plugins.</p>
</div>
<div class="section" id="virtual-environments">
<h2>Virtual Environments</h2>
<p>The first set of virtual environment (venv) support was finally merged.  This
work has exposed a number of assumptions on both DevStack and the projects themselves
that have needed to be handled.  The most recent is that <tt class="docutils literal">rootwrap</tt> is called
from the services without a fully-qualified path, relying on a <tt class="docutils literal">PATH</tt> search.
Normally this is a Bad Thing(TM) in conjunction with <tt class="docutils literal">sudo</tt> use, and I think
that applies to this situation too.  When venvs are active, the <tt class="docutils literal"><span class="pre">{project}-rootwrap</span></tt>
binary is not in the system <tt class="docutils literal">PATH</tt>, nor the one configured in <tt class="docutils literal">sudo's secure_path</tt>.
We need to now add each venv <tt class="docutils literal">/bin</tt> directory to the <tt class="docutils literal">secure_path</tt> so the
<tt class="docutils literal"><span class="pre">{project}-rootwrap</span></tt> binary can be found.</p>
<p><a class="reference external" href="https://review.openstack.org/168773">Review 168773</a> extracts the basic <tt class="docutils literal">rootwrap</tt> configuration for Cinder and Nova
into <tt class="docutils literal">lib/rootwrap</tt> and adds a function to maintain a useful <tt class="docutils literal">secure_path</tt>
setting for <tt class="docutils literal">sudo</tt>.</p>
</div>
<div class="section" id="other-devstack-bits">
<h2>Other DevStack Bits</h2>
<p>Sean Dague (sdague) nuked the <tt class="docutils literal">INSTALL_TESTONLY_PACKAGES</tt> setting and set the
code to always install those packages, ie as if <tt class="docutils literal">INSTALL_TESTONLY_PACKAGES=True</tt>.
We felt that the evolution of DevStack no longer made sense to maintain this
distinction, some may argue it never was needed in the first place.  They can now
say 'I told you so' and buy us a <tt class="docutils literal">$COLD_BEVERAGE</tt> in Vancouver.</p>
<p>Some travel delays and spotty on-board wifi on the trip home led to a semi-irregular
<a class="reference external" href="https://review.openstack.org/168616">cleanup review</a> that fixed a bunch of Shocco docs build errors and spellings
and comment spacings and most importantly, the capitalization of 'DevStack'.</p>
</div>
</div>
<div class="section" id="grenade">
<h1>Grenade</h1>
<p>The Grenade plugin story has not been completed, it is in the first set of draft
rewrites to remove the zombies and vampires and make it just a 'plugin exiled
to project repo' kind of story.</p>
<p>There were a pair of minor reviews landed to support the DevStack/Neutron rework
but they demanded more lines and were relegated to the 'C' story that parallels
Rosencrantz and Guildenstern, who of course <a class="reference external" href="http://en.wikipedia.org/wiki/Rosencrantz_and_Guildenstern_Are_Dead">are now dead</a>.</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>great, another Sean, spelled the same way even.  Let's call him 'Other Sean'</td></tr>
</tbody>
</table>
</div>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>Plug In To OpenStackClient</title>
      <link>http://hackstack.org/x/blog/2015/03/08/plug-in-to-openstackclient</link>
      <pubDate>Sun, 08 Mar 2015 03:08:00 CDT</pubDate>
      <category><![CDATA[openstackclient]]></category>
      <guid isPermaLink="false">4rzr9Siky6QjdRP6hLDYAA_XQ8E=</guid>
      <description>Plug In To OpenStackClient</description>
      <content:encoded><![CDATA[<div class="document">
<p><a class="reference external" href="http://docs.openstack.org/developer/python-openstackclient/">OpenStackClient</a> has had plugin support for a while now and it is being used by real-world OpenStack project clients such as <a class="reference external" href="https://wiki.openstack.org/wiki/Congress">Congress</a>.  I've also been using it as an entry point (ha!) for some of my experimental command setups, and so can you.</p>
<div class="section" id="osc-debug">
<h1>osc-debug</h1>
<p>I've spent a lot of time debugging OSC lately in preparation for my favorite new feature yet-to-come, support for the new <tt class="docutils literal"><span class="pre">--os-cloud</span></tt> option that takes advantage of <tt class="docutils literal"><span class="pre">os-client-config</span></tt>'s cloud configuration file abilities.  Much of this debugging is necessarily around authentication and it became obvious to me that a built-in way to see what OSC was using for authentication might be handy and <tt class="docutils literal"><span class="pre">osc-debug</span></tt> was born.</p>
<p>As far as plugins go, <a class="reference external" href="https://github.com/dtroyer/osc-debug">osc-debug</a> is pretty ordinary.  It just adds three new commands (so far) that dump internal OSC state information.</p>
<div class="section" id="api-list">
<h2>api list</h2>
<p>A mash-up of service, region and endpoint listings.  <tt class="docutils literal">api list</tt> coughs up the basic information in the service catalog returned by the Identity authentication request.  It shows the available services by type, name and region.  With a little help from the <tt class="docutils literal"><span class="pre">--long</span></tt> option it adds the actual endpoint URL and a list of the supported versions at that endpoint.</p>
<p>The version support output needs a bit of explaining.  Nearly every OpenStack service catalog is configured to include a service API version in the URL.  This means that to use a different version requires 'knowledge'.  But here we know that these versions are nearly always in the form of <tt class="docutils literal">vNNN</tt> in the URI path.</p>
<p><tt class="docutils literal">api list</tt> starts at the base URI and looks for returned version information in a couple of the usual JSON formats.  If not found it loops adding the URI path components one at a time, stopping when it finds a recognized version response.</p>
<p>The returned service catalog entries can be filtered by service type <tt class="docutils literal"><span class="pre">--type</span></tt> or service name <tt class="docutils literal"><span class="pre">--name</span></tt>.</p>
<pre class="literal-block">
osc api list
    [--type &lt;service-type&gt;]
    [--name &lt;service-name&gt;]
    [--long]
</pre>
</div>
<div class="section" id="auth-show">
<h2>auth show</h2>
<p><tt class="docutils literal">auth show</tt> displays the authentication information that OSC will use to perform authentication.  This command stops just before authentication would otherwise occur so you can see exactly what has been collected from the command line options, environment variables and <tt class="docutils literal"><span class="pre">os-client-config</span></tt> file.</p>
<p>Note that this is one of the rare 'show' commands that does not take a positional argument to determine what to show.  This is due to there being ony one thing (authentication options) to choose from, but wanting to present the output in the traditional show command format.  This makes grabbing any of these values in a shell script trivial using the <tt class="docutils literal"><span class="pre">--format</span> shell</tt> option.</p>
<p>Also, <tt class="docutils literal">os_password</tt> is not displayed, because, duh.</p>
<pre class="literal-block">
osc auth show
</pre>
</div>
<div class="section" id="auth-type-list">
<h2>auth type list</h2>
<p><tt class="docutils literal">auth type list</tt> simply lists the authentication plugin types installed and their entry point targets.  Handy to see why things are not working as expected.</p>
<pre class="literal-block">
osc auth type list
</pre>
</div>
<div class="section" id="auth-type-show">
<h2>auth type show</h2>
<p><tt class="docutils literal">auth type show</tt> shows details of the specified auth plugin type.  This includes the options that the plugin type defines.  Note that the option names are the internal names, OSC will add <tt class="docutils literal"><span class="pre">--os-</span></tt> prefix to command lise options and <tt class="docutils literal">OS_</tt> prefix, plus forcing uppercase and replacing <tt class="docutils literal">-</tt> with <tt class="docutils literal">_</tt> for environment variables.</p>
<pre class="literal-block">
osc auth type show
    &lt;auth-type&gt;
</pre>
</div>
</div>
<div class="section" id="osc-quintette">
<h1>osc-quintette</h1>
<p><a class="reference external" href="https://github.com/dtroyer/osc-quintette">osc-quintette</a> is where the experimentation really gets going.  This oddly-named <a class="footnote-reference" href="#id4" id="id2">[1]</a> plugin has a couple of things, the most interesting one is how the server create command has been extended to accept --ram, --disk and --vcpu arguments to auto-select a matching flavor for the new server.</p>
<p>While the functionality is nice, the interesting bit is how the stock commands are extended.</p>
<div class="section" id="flavor-find">
<h2>flavor find</h2>
<p>This is the functional basis for the enhanced <tt class="docutils literal">server create</tt> command, directly searching for matching flavors that meet or exceed the specified values for RAM, disk and virtual CPUs.</p>
<p>What is the difference between a <tt class="docutils literal">find</tt> and <tt class="docutils literal">list</tt> command?  I don't know yet.  <tt class="docutils literal">List</tt> + filtering == <tt class="docutils literal">find</tt> maybe, but remember, this is experimental for a reason.</p>
<pre class="literal-block">
osc flavor find
    [--ram &lt;size-mb&gt;]
    [--disk &lt;size-gb&gt;]
    [--vcpus &lt;vcpus&gt;]
</pre>
</div>
<div class="section" id="server-create">
<h2>server create</h2>
<p>Extends the stock <tt class="docutils literal">server create</tt> by adding the options to select a flavor directly based on RAM, disk and/or virtual CPUs.</p>
<pre class="literal-block">
osc server create
    [--ram &lt;size-mb&gt;]
    [--disk &lt;size-gb&gt;]
    [--vcpus &lt;vcpus&gt;]
    ...
    &lt;server-name&gt;
</pre>
</div>
<div class="section" id="server-show">
<h2>server show</h2>
<p>Another command that extends the stock version by changing the output displayed, in this case swapping <tt class="docutils literal">project_id</tt> for <tt class="docutils literal">tenant_id</tt>.  This is something that needs to be done in OSC itself as part of our &quot;never show the user a 'tenant'&quot; campaign.</p>
</div>
<div class="section" id="show-flavor">
<h2>show flavor</h2>
<p>Yes!  I can restore my long-lost <tt class="docutils literal">&lt;action&gt; &lt;object&gt;</tt> command format just by putting the right things into <tt class="docutils literal">setup.cfg</tt>.  Unfortunately, the command class does not know (yet) which command form was given to call it so changing behaviour is not yet possible.  This requires a patch to <tt class="docutils literal">cliff</tt> that is in progress and should be released soon.</p>
</div>
</div>
<div class="section" id="what-else">
<h1>What Else?</h1>
<p>Imagination is all that is required to go from here.  Go forth and plugin.</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>The word <cite>quintette</cite> comes directly from the name of <a class="reference external" href="http://raymondscott.com/">Raymond Scott's</a> small band in the 1930's, it is what I was listening to when I neede a name.  Much of his work from this era will sem eerily familiar to those who have seen Warner Brothers shorts scored by <a class="reference external" href="http://www.imdb.com/name/nm0006298/">Carl Stalling</a> in the 1940's and 1950's. I'm planning to propose <a class="reference external" href="https://archive.org/details/Powerhouse_657">Powerhouse</a> as the Official OpenStack Theme. Look it up...</td></tr>
</tbody>
</table>
</div>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>Real World DevStack Configuration</title>
      <link>http://hackstack.org/x/blog/2015/02/11/real-world-devstack-configuration</link>
      <pubDate>Wed, 11 Feb 2015 15:02:11 CST</pubDate>
      <category><![CDATA[devstack]]></category>
      <guid isPermaLink="false">Axz6zrHjweiMkqPu6Fy3pk47fBY=</guid>
      <description>Real World DevStack Configuration</description>
      <content:encoded><![CDATA[<div class="document">
<p>Configuring DevStack for development use is a trail of Google searches and
devstack.org reading and all sorts of things.  In my experience, the best and hardest
source of what to do is experience.  And we all know how experience is the bridge
between Bad Judgement and Good Judgement.[]</p>
<div class="section" id="local-conf">
<h1>local.conf</h1>
<p>This is DevStack's configuration file.  It will never be modified by DevStack.</p>
<div class="section" id="localrc">
<h2>localrc</h2>
<p>Now just a section in local.conf, <tt class="docutils literal">localrc</tt> used to be the main config file.
References to it should be mentally translated to <tt class="docutils literal">local.conf [[local|localrc]]</tt>
section.</p>
<p>I also tend to carry a number of config bits commented out to make changing quick.
I'll leave those in to illustrate alternatives to my defaults.</p>
<div class="section" id="logging">
<h3>Logging</h3>
<pre class="literal-block">
LOGDIR=$DEST/logs
LOGFILE=$LOGDIR/stack.sh.log  # why didn't bare name work???
</pre>
<p>The logging support has been recently revamped to use a more conventional
configuration.  <tt class="docutils literal">LOGDIR</tt> will default to <tt class="docutils literal">$DEST/logs</tt> and all log
files will be found here.  <tt class="docutils literal">LOGFILE</tt> will be honored as always, putting
the stack.sh trace log in that location; if <tt class="docutils literal">LOGFILE</tt> does not include
a path, it becomes <tt class="docutils literal"><span class="pre">$LOGDIR/$LOGFILE</span></tt>.</p>
<p>The services logs (aka screen logs) no longer default to a screen-specific
subdirectory, unless <tt class="docutils literal">SCREEN_LOGDIR</tt> is set.  It is deprecated and will be
removed in the future.</p>
</div>
<div class="section" id="network-addressing">
<h3>Network Addressing</h3>
<pre class="literal-block">
FIXED_RANGE=10.254.1.0/24
</pre>
<p>Set <tt class="docutils literal">FIXED_RANGE</tt> away from the default <tt class="docutils literal">10.0.0.0/24</tt> because, well, many
clouds use 10/8 for various things and some of them start at the beginning.
Running DevStack in a cloud VM requires that the DevStack network addresses do
not overlap with the host cloud networks.  Pick a range that isn't at the top
or the bottom to (slightly) reduce the chances of collision.  This is safe for
the neighborhoods I cloud in.</p>
</div>
<div class="section" id="services">
<h3>Services</h3>
<p>For my normal workflow, I want debugging bits enabled and services I am not using disabled.</p>
<pre class="literal-block">
enable_service dstat
disable_service h-eng h-api h-api-cfn h-api-cw
disable_service horizon
#enable_service s-proxy s-object s-container s-account
</pre>
<p>I typically don't use Heat or Horizon, you know, being the CLI guy and all.
Swift is not added by default because it takes a toll on memory use, my laptop
is not well-endowed in that area so 2G VMs are necessary whenever possible.  In
the cloud VMs this is not an issue.</p>
</div>
<div class="section" id="neutron">
<h3>Neutron</h3>
<pre class="literal-block">
# Nova Net
enable_service n-net
disable_Service q-svc q-agt q-dhcp q-l3 q-meta

# Neutron
# NETWORK_GATEWAY must be in the FIXED_RANGE network
#NETWORK_GATEWAY=10.254.1.1
#disable_service n-net
#enable_service q-svc q-agt q-dhcp q-l3 q-meta
</pre>
<p>Neutron may or may not be the default in DevStack by the time you read this,
I've stopped taking chances, I want to know what I get, which by default is
Nova Net for as long as possible, again mostly for memory and complexity reasons.</p>
<p>Note that Neutron in the default config requires <tt class="docutils literal">NETWORK_GATEWAY</tt> to be set
inside the network defined by <tt class="docutils literal">FIXED_RANGE</tt>.  Nova Net does not require this,
although it is mostly harmless to define anyway.</p>
</div>
<div class="section" id="legacy-nova-bits">
<h3>Legacy Nova Bits</h3>
<pre class="literal-block">
disable_service n-obj n-crt
</pre>
<p><tt class="docutils literal"><span class="pre">n-obj</span></tt> is the Nova Object Service, left over from the euca2ools bundle command's
need of an S3 service.  That's it.  Same with <tt class="docutils literal"><span class="pre">n-crt</span></tt>.  They should be removed
as defaults soon if not already.</p>
</div>
</div>
<div class="section" id="nova-conf">
<h2>nova.conf</h2>
<p>Set values here via <tt class="docutils literal">local.conf</tt>:</p>
<pre class="literal-block">
[[post-config|$NOVA_CONF]]
[DEFAULT]
api_rate_limit = False
</pre>
<p>Rate limiting can be a problem during testing, nuke it.</p>
</div>
</div>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>How Dost Thy Cloud Know Me, Let Me Count The Ways</title>
      <link>http://hackstack.org/x/blog/2014/10/24/how-dost-thy-cloud-know-me-let-me-count-the-ways</link>
      <pubDate>Fri, 24 Oct 2014 10:24:00 CDT</pubDate>
      <category><![CDATA[openstackclient]]></category>
      <guid isPermaLink="false">PTGCLOW1XYo6Sv4GvQN-GZU3W7Y=</guid>
      <description>How Dost Thy Cloud Know Me, Let Me Count The Ways</description>
      <content:encoded><![CDATA[<div class="document">
<p>One of the coolest (IMHO) new features <a class="footnote-reference" href="#id2" id="id1">[1]</a> recently added to OpenStackClient is its leveraging of a new-ish feature of Keystone's client library, authentication plugins.  As that name implies, this allows for Keystone client to be able to use an extendable set of authentication backends for validating users.  At press time (keypress time for the pedantic) the freshly released <a class="reference external" href="https://pypi.python.org/pypi/python-keystoneclient">python-keystoneclient</a> 0.11.2 includes the traditional password method, a new variant on the token method and a recent addition supporting SAML2.</p>
<p>Happily, the <a class="reference external" href="http://git.openstack.org/cgit/openstack/python-openstackclient">master branch</a> of OpenStackClient has learned how to take advantage of these plugins, plus any additional ones written for Keystone client.  This creates a new problem because the authentication type can not always be inferred and needs to be supplied by the user.  And thus we arrive at the <em>Topic of the Day</em>.</p>
<div class="section" id="but-first-preview-time">
<h1>But First, Preview Time</h1>
<p>There is one additional yet-to-come feature that I can't resist mentioning now that it has been <a class="reference external" href="https://review.openstack.org/129795">proposed for review</a>. It leverages mordred's <a class="reference external" href="http://git.openstack.org/cgit/stackforge/os-client-config">os-client-config</a> module to read configuration information from a file by name.  In plain language, rather than set up a handful of environment variables or command-line options, all of the authentication and other configuration for OSC can be stashed in a YAML file and called by name:</p>
<pre class="literal-block">
openstack --os-cloud devstack-1 image list --long
</pre>
<p>This is also step one in simplifying dealing with multiple clouds:</p>
<pre class="literal-block">
for cloud in devstack-1 hpcloud-az2 rax-ord; do
    openstack --os-cloud image list --long
</pre>
<p>It is a small thing, but small things often make us happy.  It figures in to the following authentication discussion that I don't want to update again in a month.  So until <tt class="docutils literal"><span class="pre">os-cloud</span></tt> support merges, ignore references to YAML, <tt class="docutils literal">CloudConfig</tt>, etc. below.</p>
<!-- mordred -->
<!-- os-cloud https://review.openstack.org/129795 -->
</div>
<div class="section" id="sources-of-truth">
<h1>Sources of Truth</h1>
<p>OpenStackClient has three sources of configuration information (in decreasing priority order):</p>
<ul class="simple">
<li>command line options</li>
<li>environment</li>
<li><tt class="docutils literal">CloudConfig</tt> (<tt class="docutils literal"><span class="pre">~/.config/openstack/clouds.yaml</span></tt> file)</li>
</ul>
<p>Once all of the sources have been processed and a single configuration object assembled, the fun can begin.  If an authentication type is not provided, the authentication options are examined to determine if one of the default types can be used. If no match is found an error is reported and a period of stillness is declared.  Rather, the program exits.</p>
<p>Note that the authentication call to the Identity service has not yet
occurred.  It is deferred until the last possible moment in order to
reduce the number of unnecessary queries to the server, such as when further
processing detects an invalid command.</p>
</div>
<div class="section" id="keystone-authentication-plugins">
<h1>Keystone Authentication Plugins</h1>
<p>The Keystone client library implements the base set of plugins.  Additional
plugins may be available from the Keystone project or other sources.
See the <a class="reference external" href="http://docs.openstack.org/developer/python-keystoneclient/authentication-plugins.html">Keystone client documentation</a> for more information.</p>
<p>There are at least three authentication types that are always available:</p>
<ul>
<li><p class="first"><strong>Password</strong>: A username and password, plus optional project and/or domain,
are used to identify the user.  This is the most common type and the
default any time a username is supplied.  An authentication URL for the
Identity service is also required.  [Required: <tt class="docutils literal"><span class="pre">--os-auth-url</span></tt>, <tt class="docutils literal"><span class="pre">--os-project-name</span></tt>, <tt class="docutils literal"><span class="pre">--os-username</span></tt>; Optional: <tt class="docutils literal"><span class="pre">--os-password</span></tt>]</p>
</li>
<li><p class="first"><strong>Token</strong>: This is slightly different from the usual token authentication
(described below as token/endpoint) in that a token and an authentication
URL are supplied and the plugin retrieves a new (scoped?) token.
[Required: <tt class="docutils literal"><span class="pre">--os-auth-url</span></tt>, <tt class="docutils literal"><span class="pre">--os-token</span></tt>]</p>
</li>
<li><p class="first"><strong>Token/Endpoint</strong>: This is the original token authentication (known as 'token
flow' in the early CLI documentation in the OpenStack wiki).  It requires
a token and a direct endpoint that is used in the API call.  The difference
from the new Token type is this token is used as-is, no call is made
to the Identity service from the client.  This type is most often used to
bootstrap a Keystone server where the token is the <tt class="docutils literal">admin_token</tt> configured
in <tt class="docutils literal">keystone.conf</tt>.  It will also work with other services and a regular
scoped token such as one obtained from a <tt class="docutils literal">token issue</tt> command.  [Required: <tt class="docutils literal"><span class="pre">--os-url</span></tt>, <tt class="docutils literal"><span class="pre">--os-token</span></tt>]</p>
<p><em>[Note that the Token/Endpoint plugin is currently supplied by OSC itself and is not available for other clients using the Keystone client lib.  It shall move to its Proper Home in Good Time.]</em></p>
</li>
<li><p class="first"><strong>Others</strong>: There are SAML and other (Kerberos?) plugins under development
that are also supported.  To use them they must be selected by supplying
the <tt class="docutils literal"><span class="pre">--os-auth-type</span></tt> options.</p>
</li>
</ul>
</div>
<div class="section" id="how-it-s-made">
<h1>How It's Made</h1>
<p><em>[Who doesn't love</em> <a class="reference external" href="http://www.sciencechannel.com/tv-shows/how-its-made">that show</a>? <em>]</em></p>
<p>The authentication process flows from OSC's <tt class="docutils literal">OpenStackShell</tt> to the New-and-Improved <tt class="docutils literal">ClientManager</tt>.</p>
<ul class="simple">
<li>But first, on import <tt class="docutils literal">api.auth</tt>:<ul>
<li>obtains the list of installed Keystone authentication
plugins from the <tt class="docutils literal">keystoneclient.auth.plugin</tt> entry point.</li>
<li>builds a list of authentication options from the plugins.</li>
</ul>
</li>
<li><tt class="docutils literal">OpenStackShell</tt> parses the command line:<ul>
<li>If <tt class="docutils literal"><span class="pre">--os-cloud</span></tt> is present read the named configuration from <tt class="docutils literal"><span class="pre">~/.config/openstack/clouds.yaml</span></tt> and create a <tt class="docutils literal">CloudConfig</tt> object<ul>
<li><tt class="docutils literal">CloudConfig</tt> also handles picking up the matching environment variables for the options</li>
</ul>
</li>
<li>The remaining global command line options are merged into the new <tt class="docutils literal">CloudConfig</tt></li>
</ul>
</li>
<li>A new <tt class="docutils literal">ClientManager</tt> is created and provided with the <tt class="docutils literal">CloudConfig</tt>:<ul>
<li>If <tt class="docutils literal"><span class="pre">--os-auth-type</span></tt> is provided and is a valid and available plugin it is used.</li>
<li>If <tt class="docutils literal"><span class="pre">--os-auth-type</span></tt> is not provided select an authentication plugin based on the existing options.  This is a short-circuit evaluation, first match wins.<ul>
<li>If <tt class="docutils literal"><span class="pre">--os-endpoint</span></tt> and <tt class="docutils literal"><span class="pre">--os-token</span></tt> are both present <tt class="docutils literal">token_endpoint</tt> is selected</li>
<li>If <tt class="docutils literal"><span class="pre">--os-username</span></tt> is present <tt class="docutils literal">password</tt> is selected</li>
<li>If <tt class="docutils literal"><span class="pre">--os-token</span></tt> is present <tt class="docutils literal">token</tt> is selected</li>
<li>If no selection has been made by now exit with error</li>
</ul>
</li>
<li>Load the selected plugin class.</li>
</ul>
</li>
<li><tt class="docutils literal">ClientManager</tt> waits until an operation that requires authentication is attempted to make the initial request to the Identity service.<ul>
<li>if <tt class="docutils literal"><span class="pre">--os-auth-url</span></tt> is not present for any of the types except
Token/Endpoint, exit with an error.</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="destinations-of-consequences">
<h1>Destinations of Consequences</h1>
<p>The changes that began with utilizing Keystone client's <tt class="docutils literal">Session</tt> are nearly complete and have added the <tt class="docutils literal">openstackclient.api.auth</tt> module and drastically restructured the <tt class="docutils literal">openstackclient.shell</tt> and <tt class="docutils literal">openstackclient.clientmanger</tt> modules.  One result is that the <tt class="docutils literal">ClientManager</tt> is now nearly self-contained with regard to its usability apart from the OSC shell.  At this time I can neither confirm nor deny that <tt class="docutils literal">ClientManager</tt> could be used as a single-point client API.  While it works (<a class="reference external" href="https://review.openstack.org/127873">one example</a>) it is not yet a stable API because it only unifies the session and auth components, passing the real work down to either the project libraries or OSC's internal API objects.  So don't go and do that.  Yet...</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Currently only in master branch, to be included in the next release.</td></tr>
</tbody>
</table>
</div>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>First Principles - Glossary</title>
      <link>http://hackstack.org/x/blog/2014/10/08/first-principles-glossary</link>
      <pubDate>Wed, 08 Oct 2014 10:08:00 CDT</pubDate>
      <category><![CDATA[openstack]]></category>
      <guid isPermaLink="false">cqT5if_QX0ab2rvyvdQbI0yrot8=</guid>
      <description>First Principles - Glossary</description>
      <content:encoded><![CDATA[<div class="document" id="openstack-terms-and-you">
<h1 class="title">OpenStack Terms and You</h1>
<p>I think we need to start from the beginning to know a bit about where we really are...and to do that we need to speak the same language.  This doesn't mean we must agree on the actual terms used, but that their definition and evidence of need are spelled out and can inform the following steps and discussion.</p>
<p>In some cases, the bikeshed will simply be in primer with placeholders until we converge an appropriate terms.</p>
<p>The Technical Committee <a class="reference external" href="https://wiki.openstack.org/wiki/Governance/Foundation/TechnicalCommittee">Charter</a> refers to some terms that should be clarified early in this process.</p>
<ul class="simple">
<li><strong>Official Programs</strong> - The current unit of organization, called a <strong>program</strong>, logically groups people and code for purposes of achieving the OpenStack project mission.  The current programs are generally teams of people woring on a common project or set of related projects.  These teams elect a Program Team Lead (PTL) who has management responsibilities to the program.  <a class="reference external" href="https://review.openstack.org/#/c/125783/">A proposal</a> to change this terminology to <strong>project team</strong> is in part intended to reinforce the idea that these are groups of people first and code repositories second.  The proposal is part of a series to re-structure the organization of OpenStack projects and by itself is mostly for clarity.  It does not appear to be controversial based on the comments so far so I will adopt it here.</li>
</ul>
<ul class="simple">
<li><strong>Program Leads</strong> - We've all grown to love the term <strong>PTL</strong> and the change from program to team can be used to re-redefine PTL as <strong>project team lead</strong> as it once was back in the day.</li>
<li><strong>Oversight</strong> - The TC charter includes <em>&quot;[the TC] still has oversight over team decisions, especially when they affect other programs or go contrary to general OpenStack project goals&quot;</em>.  There is concern about the balance between project rights and responsibilities changing.  There may also be concerns over what that balance is today.</li>
</ul>
<p>I'm looking for the baked-in connection between governance organization and deliverables.  Today we have a 1:1 between official teams (programs) and their participation in the &quot;integrated release&quot;.  Many of the proposals floating about disconnect those.</p>
<ul>
<li><p class="first"><strong>Coordinated Release Cycle</strong> - The time period roughly starting at or just before the semi-annual Design Summit and ending approximately six months later, again just before the next Design Summit.</p>
</li>
<li><p class="first"><strong>Release Artifacts</strong> - The output of the process formerly known as <em>integrated release</em>.  These are the major output of the <em>coordinated release cycle</em> and typically what distributions would consume in building their periodic releases.</p>
</li>
<li><p class="first"><strong>Project Groups</strong> - Project groups are simply groups of related projects and/or project teams that are dependent on each other and it is often useful to consider the projects together for certain matters.  For example <strong>Group C</strong> includes Nova, Glance, Cinder and Neutron.  Other groups might include <strong>Group I</strong> (Keystone and plugins), <strong>Group O</strong> (Swift), <strong>Group W</strong> (<a class="reference external" href="http://en.wikipedia.org/wiki/Alice's_Restaurant">litterbugs</a>), <strong>Group H</strong> (Ironic and other hypervisor drivers), <strong>Group D</strong> (Trove), <strong>Group M</strong> (Zaqar), and so on.  Many groups may only have one member if there are not multiple projects with a strongly set of similar or mutual dependencies.</p>
<p>One use of project groups is in simplifying the relationship diagram between projects; the diagram between projects within the group can focus on that subset and the diagram between groups can minimize the effect of the intra-group relationships.  These diagrams should be useful in informing testing policy and requirements.</p>
<p>These groups map into my <a class="reference external" href="/x/blog/2014/10/03/a-funny-thing-happened-on-the-way-to-the-summit/">layers description</a> with layer one comprised of Groups I and most of C and layer 2 comprised of Groups O, H and the remainder of C (Cinder).  Remaining groups of official OpenStack projects make up layer 3.</p>
</li>
<li><p class="first"><strong>Integrated Release</strong> - The first step is to change the term <em>integrated release</em> to something better defined and less overloaded.  This is highly contentious as you might expect.  I had intended on using <strong>nucleus</strong> to describe this chewy middle of OpenStack because it has all sorts of metaphorical nooks and crannies to be mined, but then I saw <strong>nuclear release</strong> in writing and decided to just use the rather archaic term <strong>bindle</strong> here instead, as in &quot;the OpenStack Bindle contains the basic cloud necessities&quot;.</p>
<p>The key part of the existing definition, <em>&quot;The OpenStack bindle is a subset of the official OpenStack projects whose member teams submit to stricter policies and oversight&quot;</em>, divides the official OpenStack projects into at least two tiers.  dhellmann describes it like this:</p>
<pre class="literal-block">
size(ecosystem) &gt; size(official-projects) &gt; size(bindle)
</pre>
<p>Inclusion in the integrated release has become the high-value attribute for many corporations judging project worthiness for contribution and/or use.  Removing this attribute is one of the major driving forces for re-considering the organizational structure in general and in renaming and clearly defining the <em>bindle</em>.</p>
<p>The makeup of the bindle defines what release artifacts are published as a result of the release process.  These projects are held to a higher bar in regards to testing, documentation in involvement of team members in horizontal OpenStack activities.</p>
</li>
</ul>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>A Funny Thing Happened On The Way To The Summit</title>
      <link>http://hackstack.org/x/blog/2014/10/03/a-funny-thing-happened-on-the-way-to-the-summit</link>
      <pubDate>Fri, 03 Oct 2014 10:03:00 CDT</pubDate>
      <category><![CDATA[openstack]]></category>
      <guid isPermaLink="false">pYh2olEpo6M1N5yA_pVxnKK2s4Q=</guid>
      <description>A Funny Thing Happened On The Way To The Summit</description>
      <content:encoded><![CDATA[<div class="document">
<p>So back in <a class="reference external" href="/x/blog/2013/09/05/openstack-seven-layer-dip-as-a-service/">the old days</a> I started throwing around different terminology to describe some of the technical relationships between OpenStack projects because it was useful to sort out things like startup order requirements in DevStack and other semi-obvious stuff.</p>
<p>And wow have things happened since then.  To recap, oh nevermind, I'm just going to take back the term <strong>layer</strong> for technical use and propose anything else other than <strong>layer 1</strong> (there is no other layer?) for the rest of the conversation. The various alternate approaches all boil down to a <strong>nucleus</strong> with a cloud (heh) of projects with probabilistic locations.  I wasn't a physics major but I do know that doesn't sound like that Q-word that shall not be spoken.</p>
<p>I think it is important to remember that one of the primary purposes of OpenStack is to enable the creation of <strong>useful clouds</strong>.  In my dictionary what makes a useful cloud is described as &quot;the set of services that enable useful work to be done&quot;.  In a cloud.</p>
<p>The original layers idea has been picked up, painted, folded, carved and whitewashed to a shadow of its original.  Even so, in the end all of the ideas still end up looking similar.  Now seems like a good time to see how the orignal layers have held up.</p>
<div class="section" id="layer-1">
<h1>Layer 1</h1>
<p><em>We're still the one...</em></p>
<p>We open with the addition of Neutron as a viable alternative to Nova Network, and the likelihood of it becoming the default configuration in DevStack early in the Juno cycle.</p>
<blockquote>
<ul class="simple">
<li>Identity (Keystone)</li>
<li>Image (Glance)</li>
<li>Network (Neutron)</li>
<li>Compute (Nova)</li>
</ul>
</blockquote>
<p>What really stands out to me now is the realization that all of these were originally part of Nova itself (plus the cinder volume service, more on that later).  They were broken apart or re-implemented to scale the development as Nova kept growing.  In fact, there is talk again of need to break out more simply because Nova continues to expand.</p>
<p>This is the smallest working set for a compute-enabled cloud.  Realistic useful clouds of course offer more than this, so we have...</p>
</div>
<div class="section" id="layer-2">
<h1>Layer 2</h1>
<p>Layer 2 services are optional in a useful compute cloud but some are also useful in their own right as non-compute cloud services.</p>
<p>So the current Layer 2 still contains:</p>
<blockquote>
<ul class="simple">
<li>Volume (Cinder)</li>
<li>Object (Swift)</li>
<li>Bare-metal (Ironic)</li>
</ul>
</blockquote>
<p>These all build on the Layer 1 nucleus and get us a practical useful cloud.  They also all have the characteristic of having dependency arrows pointing <em>out</em> of Layer 1 when used with a compute cloud, such as Glance using Swift as its backend store.  This is a defining characteristic that brings a project in to Layer 2.</p>
<p>Even though Cinder was literally carved out of the Nova code base it stays in Layer 2 because it is an optional service to a Layer 1 cloud.  Manila will also fit here for the same reasons.</p>
<p>I neglected to mention last time the ability of Swift to stand alone as a useful cloud service as it has maintained its own authentication capability.  However, using it with any other OpenStack services requires Swift to use Keystone.</p>
<p>I also think it is worth considering the direction of the trademark usage constraints the board is refining with the DefCore work.  The current DefCore capability proposal is satisfied using only Layer 1 and 2 projects.  Also, the stand-alone services currently would not be able to qualify for trademark usage when deployed alone.</p>
</div>
<div class="section" id="layer-3">
<h1>Layer 3</h1>
<p>Do something useful.  Host services for paying customers.  Provide Lego blocks for them to build awesome cloud apps.  Warn about runaway <tt class="docutils literal">while true; done</tt> loops.  Count cycles burned and bits sent so paying customers know what to pay.  Communicate with your useful cloud.</p>
<p>The rest of the OpenStack-affiliated projects (for some value of <em>affiliated</em>) go in Layer 3 to populate the <strong>big tent</strong>.  If we've done our job right the majority of everything else should be able to be accomplished without special consideration from Layers 1 and 2.  Broad categories of Layer 3 projects include:</p>
<blockquote>
<ul class="simple">
<li>User Interfaces - You need one but a feature of well documented REST APIs is allowing the client side to be easily replaceable.<ul>
<li>Orchestration (Heat) (it is basically a smart automated cloud client, no?)</li>
<li>Web UI (Horizon)</li>
<li>&lt;insert-one-of-the-other-CLI-or-web-clients-here&gt;</li>
</ul>
</li>
<li>Something-as-a-Service - These are all services a deployer may choose to offer.<ul>
<li>Database (Trove)</li>
<li>Message Passing (Zaqar)</li>
</ul>
</li>
<li>Tracking Snooping and Counting - Keeping an eye on the useful cloud<ul>
<li>Telemetry (Ceilometer)</li>
</ul>
</li>
</ul>
</blockquote>
<p>Why is Heat in Layer 3???  Heat is essentially a smart automated cloud client and should be treated as one.   It needs to meet the same requirements for API compatibility to be useful over time.</p>
</div>
<div class="section" id="layer-4">
<h1>Layer 4</h1>
<p>Layer 4 is everything else that is not OpenStack-affiliated but might be a part of an especially useful OpenStack cloud.  Things like Ceph or Apache jclouds are useful with and as part of OpenStack clouds, but they also have a life of their own and we should respect that and not call late at night.</p>
</div>
<div class="section" id="what-about-layer-0">
<h1>What About Layer 0?</h1>
<p>Ah, right, where the Libraries live.  The last year has seen significant changes to how OpenStack-related libraries are integrated with a number of Oslo libraries being released stand-alone.  In most cases these can and should be thought of as dependencies just as any non-OpenStack project dependency (like <tt class="docutils literal">SQLAlchemy</tt> or <tt class="docutils literal">requests</tt>) that happen to live in either the <tt class="docutils literal">openstack</tt> or <tt class="docutils literal">stackforge</tt> namespaces in our Git repositories.</p>
<p>It also seems appropriate to add the client API libraries and SDKs to Layer 0 as the dependency model and release schedule is very similar to the other libraries.  I am specifically not including command-line interfaces here as I think those belong in Layer 3 but the project client libraries have an embedded CLI so the'll straddle the boundaries no matter what.</p>
</div>
<div class="section" id="so-how-do-we-govern-and-test-all-this">
<h1>So How Do We Govern and Test All This?</h1>
<p>OK, I lied.  I said I would skip this, but anyone still reading must think this is has a thread of merit, right?  I choose to make that assumption going forward, and those of you still reading for a laugh, here is your cue.</p>
<p>I'll lay out an overview of a developers perspective because I am primarily an OpenStack developer and I need the world to know what I think.  However, I am also an application developer and cloud end-user so those perspectives are not lost.  I have not managed to add cloud deployer to my CV, yet.</p>
<div class="section" id="releases">
<h2>Releases</h2>
<p>If you turn your head sideways and squint, the Layer picture can also be grouped according to release-able/deploy-able units with decently defined and documented interfaces between them.</p>
<p>Maintaining the current notion of an Integrated Release the layers fall out like this:</p>
<blockquote>
<ul class="simple">
<li>Layers 1 and 2 <em>are</em> the Integrated Release.  The services required to meet DefCore are currently a subset of these layers.</li>
<li>Layer 3 projects treat the Integrated Release as a dependency like any other they may have so they can have the freedom to iterate at a pace that suits the service being provided.  Trove probably needs fewer releases in the next year than Zaqar.</li>
</ul>
</blockquote>
<p>Switching to a more modularized set of released units the first 'natural' groupings are:</p>
<blockquote>
<ul class="simple">
<li>Layer 1 plus the semi-tightly coupled Nova projects like Cinder (and Manila) comprise a Compute Release.</li>
<li>Swift comprises an Object Store release</li>
<li>Ironic comprises an (insert-catchy-name-here) release and not in the Compute Release as it can also stand alone (right?)</li>
<li>Actually, everything else is on its own because Independence From Tyranny!  Things that need to talk to each other or to the Integrate projects need to correctly identify and handle the documented APIs available to them.</li>
</ul>
</blockquote>
<p>Basically, this alternative splits the Integrated Release into a Compute Release and two stand-alone releases for Swift and Ironic.  The Release Management team may reconsider the criteria required for them to continue to handle other project releases or allow (force?) the projects to handle their own.</p>
<p>Note how the difference in those two approaches to releases is exactly two things, pulling Swift and Ironic out of the Integrated Release bundle so they can stand alone.</p>
</div>
<div class="section" id="testing">
<h2>Testing</h2>
<p>As current work is showing, the actual detailed relationships between OpenStack services is very complex.  Describing it to a level of detail that can drive a test matrix is not simple.  We can, however, reduce the problem space by re-thinking at a higher level what needs to be tested together.</p>
<p>Layers 1 and 2 are really where the work needs to be done. By changing the perspective of Layer 3 projects we can reduce the piling-on of additional projects that are currently in our Test All The Things check/gate jobs.  Individual project relationships across that boundary may be important enough to warrant specific test jobs but those are considered exceptions and not the rule.</p>
<p>A significant amount of the gains to me made here are contingent on the projects developing comprehensive functional tests.</p>
</div>
</div>
<div class="section" id="horizontal-projects">
<h1>Horizontal Projects</h1>
<p>While it feels like I'm saving the best for last, in reality much of the above has to have some structure to know the scope that Infrastructure, Docs and QA need to be able to support.  Focusing these on Layers 1 and 2 provides a clear limit to the scope required.  This is not to say that other projects are not going to be accommodated, particularly those already in the current release, but it does say that it is not assured.</p>
</div>
<div class="section" id="now-what-smart-guy">
<h1>Now What Smart Guy?</h1>
<p>With my thoughts on Layers updated to include the governance and testing considerations it is time to match up other perspectives, flesh out the above with the new information and catch up on the plethora of other posts on this topic.</p>
<p>Film at eleven...</p>
</div>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>OpenStack Low Level API</title>
      <link>http://hackstack.org/x/blog/2014/09/15/openstack-low-level-api</link>
      <pubDate>Mon, 15 Sep 2014 09:15:00 CDT</pubDate>
      <category><![CDATA[openstack]]></category>
      <category><![CDATA[api]]></category>
      <category><![CDATA[client]]></category>
      <guid isPermaLink="false">eIZng7kEM5KyvZSHnaO9Z1LG1s8=</guid>
      <description>OpenStack Low Level API</description>
      <content:encoded><![CDATA[<div class="document">
<p>The current Python library situation for OpenStack is, sorry to say, a mess.  Cleaning it up requires essentially starting over and abstracting the individual REST APIs to usable levels.  With OpenStackClient I started from the top and worked down to make the CLI a better experience.  I think we have proved that to be a worthwhile task.  Now it is time to start from the bottom and work up.</p>
<p>The existing libraries utilize a Manager/Resource model that may be suitable for application work, but every project's client repo was forked and changed so they are all similar but maddeningly different.  However, a good idea or two can be easily extracted and re-used in making things as simple as possible.</p>
<p>I originally started with no objects at all and went straight to top-level functions, as seen in the current <tt class="docutils literal">object.v1.lib</tt> APIs in OSC.  That required passing around the session and URLs required to complete the REST calls, which OSC already has available, but it is not a good general-purpose API.</p>
<p>I've been through a number of iterations of this and have settles on what is described here, a low-level API for OSC and other applications that do not require an object model.</p>
<div class="section" id="api-baseapi">
<h1>api.BaseAPI</h1>
<p>We start with a <a class="reference external" href="https://github.com/dtroyer/python-openstackclient/blob/low-level-api/openstackclient/api/api.py#L22">BaseAPI</a> object that contains the common operations.  It is pretty obvious there are only a couple of ways to get a list of resources from OpenStack APIs so the bulk of that and similar actions are here.</p>
<p>It is also very convenient to carry around a couple of other objects so they do not have to be passed in every call.  <a class="reference external" href="https://github.com/dtroyer/python-openstackclient/blob/low-level-api/openstackclient/api/api.py#L22">BaseAPI</a> contains a <tt class="docutils literal">session</tt>, <tt class="docutils literal">service type</tt> and <tt class="docutils literal">endpoint</tt> for each instance.  The <tt class="docutils literal">session</tt> is a <tt class="docutils literal">requests.session.Session</tt>-compatible object.  In this implementation we are using the <tt class="docutils literal">keystoneclient.session.Session</tt> which is close enough.  We use the ksc Session to take advantage of keystoneclient's authentication plugins.</p>
<p>The <tt class="docutils literal">service type</tt> and <tt class="docutils literal">endpoint</tt> attributes are specific to each API.  <tt class="docutils literal">service type</tt> is as it is used in the Service Catalog, i.e. <tt class="docutils literal">Compute</tt>, <tt class="docutils literal">Identity</tt>, etc.  <tt class="docutils literal">endpoint</tt> is the base URL extracted from the service catalog and is prepended to the passed URL strings in the <tt class="docutils literal">API</tt> method calls.</p>
<p>Most of the methods in <a class="reference external" href="https://github.com/dtroyer/python-openstackclient/blob/low-level-api/openstackclient/api/api.py#L22">BaseAPI</a> also are meant as foundational building blocks for the service APIs.  As such they have a pretty flexible list of arguments, many of them accepting a <tt class="docutils literal">session</tt> to override the base <tt class="docutils literal">session</tt>.  This layer is also where the JSON decoding takes place, these all return a Python <tt class="docutils literal">list</tt> or <tt class="docutils literal">dict</tt>.</p>
<p>The derived classes from <a class="reference external" href="https://github.com/dtroyer/python-openstackclient/blob/low-level-api/openstackclient/api/api.py#L22">BaseAPI</a> will contain all of the methods used to access their respective REST API.  Some of these will grow quite large...</p>
</div>
<div class="section" id="api-object-store-apiv1">
<h1>api.object_store.APIv1</h1>
<p>While this is a port of the existing code from OpenStackClient, <a class="reference external" href="https://github.com/dtroyer/python-openstackclient/blob/low-level-api/openstackclient/api/object_store.py#L26">object_store.APIv1</a> is still essentially a greenfield implementation of the <tt class="docutils literal"><span class="pre">Object-Store</span></tt> API.  All of the path manipulation, save for prepending the base URL, is done at this layer.</p>
</div>
<div class="section" id="api-compute-apiv2">
<h1>api.compute.APIv2</h1>
<p>This is one of the big ones.  At this point, only <tt class="docutils literal">flavor_list()</tt>, <tt class="docutils literal">flavor_show()</tt> and <tt class="docutils literal">key_list()</tt> have been implemented in <a class="reference external" href="https://github.com/dtroyer/python-openstackclient/blob/low-level-api/openstackclient/api/compute.py#L19">compute.APIv2</a>.</p>
<p>Unlike the <tt class="docutils literal"><span class="pre">object-store</span></tt> API, the rest of the OpenStack services return resources wrapped up in a top-level dict keyed with the base name of the resource.  This layer shall remove that wrapper so the returned values are all directly lists or dicts.  This removed the variations in server implementations where some wrap the list object individually and some wrap the entire list once.  Also, Keystone's tendency to insert an additional <tt class="docutils literal">values</tt> key into the return.</p>
</div>
<div class="section" id="api-identity-vx-apivx">
<h1>api.identity_vX.APIvX</h1>
<p>The naming of <a class="reference external" href="https://github.com/dtroyer/python-openstackclient/blob/low-level-api/openstackclient/api/identity_v2.py#L19">identity_v2.APIv2</a> and <a class="reference external" href="https://github.com/dtroyer/python-openstackclient/blob/low-level-api/openstackclient/api/identity_v3.py#L19">identity_v3.APIv3</a> is a bit repetitive but putting the version into the module name lets us break down the already-long files.</p>
<p>At this point, only <tt class="docutils literal">project_list()</tt> is implemented in an effort to work out the mechanics of supporting multiple API versions.  In OSC, this is already handled in the ClientManager and individual client classes so there is not much to see here.  It may be different otherwise.</p>
</div>
<div class="section" id="osc-usage">
<h1>OSC Usage</h1>
<p>To demonstrate how this API is used, I've added an <a class="reference external" href="https://github.com/dtroyer/python-openstackclient/blob/low-level-api/openstackclient/api/api.py#L22">BaseAPI</a> instance to the existing client objects that get stored in the <tt class="docutils literal">ClientManager</tt>.  For example, the addition for <a class="reference external" href="https://github.com/dtroyer/python-openstackclient/commit/2bfc9e1b722cb89670ba4878f10fb07d9c68519f#diff-9d500da5511aec08e46397bc7a4b25bdR75">compute.client</a> is one object instantiation and an import.  Now in OSC, <tt class="docutils literal">clientmanager.compute.api</tt> has all of the (implemented) <tt class="docutils literal">Compute</tt> API methods.</p>
<p>Using it in the flavor commands is a <a class="reference external" href="https://github.com/dtroyer/python-openstackclient/commit/2bfc9e1b722cb89670ba4878f10fb07d9c68519f#diff-1be98e03ae4586b73d8ad5f62f0dc578L163">simple change</a> to call <tt class="docutils literal">compute.api</tt> methods rather than the <tt class="docutils literal">compute.flavor.XXX</tt> methods.</p>
<p>Setting up for multiple API versions took a bit more work, as shown in <a class="reference external" href="https://github.com/dtroyer/python-openstackclient/commit/2bfc9e1b722cb89670ba4878f10fb07d9c68519f#diff-f7023c81f38d2c70e77da533164db4b6L31">identity.client</a>.  A parallel construction to the client class lookup is required, and would totally replace the existing version lookup once the old client is no longer required.</p>
</div>
<div class="section" id="fluff">
<h1>Fluff</h1>
<p>One other cool feature is utilizing <tt class="docutils literal">requests_mock</tt> for testing from the start.  It works great and has not the problems that rode along with <tt class="docutils literal">httpretty</tt>.</p>
</div>
<div class="section" id="now-what">
<h1>Now What?</h1>
<p>Many object models could be built on top of this API design.  The <tt class="docutils literal">API</tt> object hierarchy harkens back to the original client lib <tt class="docutils literal">Manager</tt> classes, except that they encompass an entire REST API and not one for each resource type.</p>
</div>
<div class="section" id="but-you-said-sanity-earlier">
<h1>But You Said 'Sanity' Earlier!</h1>
<p>Sanity in terms of coalescing the distinct APIs into something a bit more common?  Yes.  However, this isn't going to fix everything, just some of the little things that application developers really shouldn't have to worry about.  I want the project REST API docs to be usable, with maybe a couple of notes for the differences.</p>
<p>For example, OSC and this implementation both use the word <tt class="docutils literal">project</tt> in place of <tt class="docutils literal">tenant</tt>.  Everywhere.  Even where the underlying API uses <tt class="docutils literal">tenant</tt>.  This is an easy change for a developer to remember.  I think.</p>
<p>Also, smoothing out the returned data structures to not include the resource wrappers is an easy one.</p>
</div>
<div class="section" id="duplicating-work">
<h1>Duplicating Work?</h1>
<p>&quot;Doesn't this duplicate what is already being done in the OpenStack Python SDK?&quot;</p>
<p>Really, no.  This is meant to be the low-level SDK API that the Resource model can utilize to provide the back-end to its object model.  Honestly, most applications are going to want to use the Resource model, or an even higher API that makes easy things really easy, and hard things not-so-hard, as long as you buy in to the assumptions baked in to the implementation.</p>
<p>Sort of like OS/X or iOS.  Simple to use, as long as you don't want to anything different.  Maybe we should call that top-most API <tt class="docutils literal">iOSAPI</tt>?</p>
</div>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>OpenWRT Images for OpenStack</title>
      <link>http://hackstack.org/x/blog/2014/08/17/openwrt-images-for-openstack</link>
      <pubDate>Sun, 17 Aug 2014 08:17:00 CDT</pubDate>
      <category><![CDATA[openstack]]></category>
      <category><![CDATA[openwrt]]></category>
      <guid isPermaLink="false">eYdqmkKAVncy1u3mOePk4UrR_wQ=</guid>
      <description>OpenWRT Images for OpenStack</description>
      <content:encoded><![CDATA[<div class="document">
<p>I've been playing with <a class="reference external" href="http://openwrt.org">OpenWRT</a> since &lt;mumble&gt;-&lt;mumble&gt; and have enjoyed building some of the smallest Linux images around.  While targeted at low-end home router platforms, it also runs on a wide variety of small SoC boards including the near-ubiqutious Raspberry Pi and my fave BeagleBone Black.</p>
<p>I've also been using an incredibly tiny OpenWRT instance on my laptop for years now to work around the 'interesting' network configuration of VirtualBox.  Building a set of VMs that need to talk to each other and to the outside world shouldn't be hard, so I added a router just like I have at home in a 48Mb VM.</p>
<p>While OpenStack typically doesn't have that need (but you never know how Neutron might be configured!) there are plenty of other purposes for such a small single-purpose VM.  So let's build one!</p>
<p>The magic in this cloud build is having an analogue to smoser's <a class="reference external" href="https://launchpad.net/cloud-init">cloud-init</a>.  The original is written in Python and has a lot of very useful features, but requiring the Python stdlib and <tt class="docutils literal"><span class="pre">cloud-init</span></tt> dependencies to be installed expands the size of the root image considerably.   My version, called <a class="reference external" href="https://github.com/dtroyer/openwrt-packages/tree/master/rc.cloud">rc.cloud</a>, is a set of shell scripts that implement a small subset of <tt class="docutils literal"><span class="pre">cloud-init</span></tt> capabilities.  [Note: I 'borrowed' the original scripts from somewhere over three years ago and for the life of me can't find out where now.  Pointers welcome.]</p>
<p>One of the most important features of <tt class="docutils literal"><span class="pre">cloud-init</span></tt> and <tt class="docutils literal">rc.cloud</tt> is configuring a network interface and enabling remote access.  OpenWRT defaults to no root password so I have to telnet to 192.168.1.1 to set root's password before Dropbear (a tiny ssh2 implementation) allows logins. Doing it with <tt class="docutils literal"><span class="pre">cloud-init</span></tt> or <tt class="docutils literal">rc.cloud</tt> instead allows automation and is a Wonderful Thing(TM).</p>
<p>This isn't a detailed How-To on building OpenWRT, there are a lot of <a class="reference external" href="http://wiki.openwrt.org/doc/howto/build">good docs</a> covering that topic.  It _is_ however, the steps I use plus some additional tweaks useful in a KVM-based OpenStack cloud.</p>
<div class="section" id="build-image-from-source">
<h1>Build Image From Source</h1>
<p>The basic build is straight out of the <a class="reference external" href="http://wiki.openwrt.org/doc/howto/build">OpenWRT wiki</a>.  I could have used the Image Builder, but I have some additional packages to include and like having control over the build configuration, such as either making sure IPv6 is present, or making sure it isn't.  And so on.</p>
<p>Configuring the OpenWRT buildroot can be a daunting task so starting with a minimal configuration is very helpful.  For a guest VM image there are a few things to consider:</p>
<ul class="simple">
<li>the VM target (Xen, KVM, etc)</li>
<li>root device name (vda2 for KVM, sda2 for others like VirtualBox)</li>
</ul>
<p>Traditionally OpenWRT has used Subversion for source control.  A move (or mirror?) on GitHub makes things easier for those of us who it it regualrly in other projects.  The <a class="reference external" href="http://wiki.openwrt.org/doc/howto/buildroot.exigence">buildroot doc</a> uses GitHub as the source so I've followed that convention.</p>
<ul>
<li><p class="first">Clone the repo:</p>
<pre class="literal-block">
git clone git://git.openwrt.org/openwrt.git
cd openwrt
</pre>
</li>
<li><p class="first">Install custom feed:</p>
<pre class="literal-block">
echo &quot;src-git dtroyer https://github.com/dtroyer/openwrt-packages&quot; &gt;&gt;feeds.conf.default
</pre>
</li>
<li><p class="first">Install packages:</p>
<pre class="literal-block">
./scripts/feeds update -a
./scripts/feeds install -a
</pre>
</li>
<li><p class="first">Check for missing packages:</p>
<pre class="literal-block">
make defconfig
</pre>
</li>
</ul>
<div class="section" id="configuration">
<h2>Configuration</h2>
<ul>
<li><p class="first">Configure:</p>
<pre class="literal-block">
make menuconfig
</pre>
</li>
<li><p class="first">Enable the following:</p>
<ul class="simple">
<li>Target System: x86</li>
<li>Subtarget: KVM guest</li>
<li>Target Images<ul>
<li><tt class="docutils literal">[*] ext4</tt></li>
<li><tt class="docutils literal">(48)</tt> Root filesystem partition size (in MB)</li>
<li><tt class="docutils literal">(/dev/vda2)</tt> Root partition on target device</li>
</ul>
</li>
<li>Base System<ul>
<li><tt class="docutils literal">{*} <span class="pre">block-mount</span></tt>  (not sure, if yes to support root fs, parted too)</li>
<li><tt class="docutils literal">&lt;*&gt; rc.cloud</tt></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Notes:</p>
<ul class="simple">
<li>Increase the root filesystem size if you do not intend to move root to another partition or increase the existing one to fit the flavor's disk size.</li>
</ul>
</div>
<div class="section" id="build">
<h2>Build</h2>
<p>It's pretty simple:</p>
<pre class="literal-block">
make -j 4
</pre>
<p>Adjust the argument to <tt class="docutils literal"><span class="pre">-j</span></tt> as appropriate for the number of CPUs on your build system.</p>
<p>When build errors occur, you'll need to run with output turned on:</p>
<pre class="literal-block">
make V=99
</pre>
</div>
</div>
<div class="section" id="configuring-the-image-for-openstack">
<h1>Configuring the Image for OpenStack</h1>
<p>As I mentioned earlier, there are a handful of changes to make to the resulting image that makes it ready for an OpenStack cloud.</p>
<ul class="simple">
<li>Set a root password - Without a root password your newly minted VM is vulnerable to a password-less telnet login if your security group rules allow that.  But more importantly, Dropbear will not allow an ssh login without a rot password.  Edit <tt class="docutils literal">/etc/shadow</tt> to set a root password</li>
<li>Configure a network interface for DHCP - This allows the first interface to obtain its IP automatically for OpenStack clouds that provide it.  Otherwise...</li>
<li>Configure <tt class="docutils literal">/etc/opkg.conf</tt> to my package repo - Packages usually need to be matched for not only their architecture but also other build flags.  Kernel modules are particularly rigid about how they can be loaded.</li>
</ul>
<div class="section" id="image-update">
<h2>Image Update</h2>
<p>All of the interesting parts below must be done as root.  So be careful.</p>
<ul>
<li><p class="first">Uncompress and copy the original image to a workspace, mount it and chroot into it:</p>
<pre class="literal-block">
gzip -dc bin/x86/openwrt-x86-kvm_guest-combined-ext4.img.gz &gt;openwrt-x86-kvm_guest-combined-ext4.img
sudo kpartx -av openwrt-x86-kvm_guest-combined-ext4.img
mkdir -p imgroot
sudo mount -o loop /dev/mapper/loop0p2 imgroot
sudo chroot imgroot
</pre>
</li>
<li><p class="first">Make the desired changes:</p>
<ul>
<li><p class="first">Set root password:</p>
<pre class="literal-block">
sed -e '/^root/ s|^root.*$|root:\!:16270:0:99999:7:::|' -i /etc/shadow
</pre>
</li>
<li><p class="first">Configure DHCP:</p>
<pre class="literal-block">
uci set network.lan.proto=dhcp; uci commit
</pre>
</li>
<li><p class="first">Configure opkg:</p>
<pre class="literal-block">
sed -e &quot;s|http.*/x86/|http://bogus.hackstack.org/openwrt/x86/|&quot; -i /etc/opkg.conf
</pre>
</li>
</ul>
</li>
<li><p class="first">Unwind the mounted image:</p>
<pre class="literal-block">
sudo umount imgroot
sudo kpartx -av openwrt-x86-kvm_guest-combined-ext4.img
</pre>
</li>
<li><p class="first">Upload it into Glance:</p>
<pre class="literal-block">
openstack image create --file openwrt-x86-kvm_guest-combined-ext4.img --property os-distro=OpenWRT OpenWRT

# Glance CLI
glance image-create --file openwrt-x86-kvm_guest-combined-ext4.img --name OpenWRT
</pre>
</li>
</ul>
</div>
</div>
<div class="section" id="additional-modifications">
<h1>Additional Modifications</h1>
<div class="section" id="extending-root-filesystem">
<h2>Extending Root Filesystem</h2>
<p>Even the smallest flavor gets a root disk a good bit larger than the typocal OpenWRT disk image.  One way to use that space is to increase the root filesystem.  OpenWRT has something called <tt class="docutils literal">extroot</tt> that is currently experimental and semi-undocumented, so I just took the radical move of partitioning the unused space and moving the root filesystem to the new partition.</p>
<p>Of course a real root expansion should be automated and added to <tt class="docutils literal">rc.cloud</tt> to mirror the <tt class="docutils literal"><span class="pre">cloud-init</span></tt> functionality.  Someday...</p>
<ul>
<li><p class="first">Install required packages if they're not part of the base build:</p>
<pre class="literal-block">
opkg update
opkg install block-mount parted
</pre>
</li>
<li><p class="first">Create a filesystem on the remaining disk and mount it:</p>
<pre class="literal-block">
parted /dev/vda -s -- mkpart primary  $(parted /dev/vda -m print | tail -1 | cut -d':' -f3) -0
mkfs.ext4 -L newroot /dev/vda3
mkdir -p /tmp/newroot
mount /dev/vda3 /tmp/newroot
</pre>
</li>
<li><p class="first">Copy the root filesystem:</p>
<pre class="literal-block">
mkdir -p /tmp/oldroot
mount --bind / /tmp/oldroot
tar -C /tmp/oldroot -cvf - . | tar -C /tmp/newroot -xf -
umount /tmp/oldroot
umount /tmp/newroot
</pre>
</li>
<li><p class="first">Update the GRUB bootloader to use the new partition:</p>
<pre class="literal-block">
mkdir -p /tmp/boot
mount /dev/vda1 /tmp/boot
sed -e 's/vda2/vda3/' -i /tmp/boot/boot/grub/grub.cfg
umount /tmp/boot
</pre>
</li>
<li><p class="first">Reboot</p>
</li>
</ul>
</div>
</div>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>More Notes on Windows Images</title>
      <link>http://hackstack.org/x/blog/2014/07/13/more-notes-on-windows-images</link>
      <pubDate>Sun, 13 Jul 2014 07:13:00 CDT</pubDate>
      <category><![CDATA[windows]]></category>
      <category><![CDATA[openstack]]></category>
      <guid isPermaLink="false">_MyylKSqiFGJ3m4qsDhVRwgOUEs=</guid>
      <description>More Notes on Windows Images</description>
      <content:encoded><![CDATA[<div class="document">
<p>This is a follow-up to <a class="reference external" href="/x/blog/2014/07/07/windows-images-for-openstack/">Windows Images for OpenStack</a> that includes some of the notes accumulated along the way.</p>
<div class="section" id="other-docs">
<h1>Other Docs</h1>
<p>Building Windows VM images is a topic that has been done to death, but the working consensus of those I've talked to is that <a class="reference external" href="http://www.florentflament.com/blog/windows-images-for-openstack.html">Florent Flament's post</a> is one of the best guides through this minefield.</p>
</div>
<div class="section" id="metadata-server-curl-commands">
<h1>Metadata Server Curl Commands</h1>
<p>Instance UUID:</p>
<blockquote>
curl <a class="reference external" href="http://169.254.169.254/openstack/latest/meta_data.json">http://169.254.169.254/openstack/latest/meta_data.json</a> | python -c 'import sys, json; print json.load(sys.stdin)[&quot;uuid&quot;]'</blockquote>
<p>Instance Name:</p>
<blockquote>
curl <a class="reference external" href="http://169.254.169.254/openstack/latest/meta_data.json">http://169.254.169.254/openstack/latest/meta_data.json</a> | python -c 'import sys, json; print json.load(sys.stdin)[&quot;name&quot;]'</blockquote>
<p>Fixed IP:</p>
<blockquote>
curl <a class="reference external" href="http://169.254.169.254/latest/meta-data/local-ipv4">http://169.254.169.254/latest/meta-data/local-ipv4</a></blockquote>
<p>Floating IP:</p>
<blockquote>
curl <a class="reference external" href="http://169.254.169.254/latest/meta-data/public-ipv4">http://169.254.169.254/latest/meta-data/public-ipv4</a></blockquote>
</div>
<div class="section" id="building-on-an-openstack-cloud">
<h1>Building on an OpenStack Cloud</h1>
<p>One of the changes to the base instructions is to perform the build in an OpenStack cloud.  The compute node must have nested virtualization enabled so KVM will run, otherwise Qemu would be used and we just don't have time for that.</p>
<p>I'm going to use <a class="reference external" href="https://github.com/cloudenvy/cloudenvy">Cloudenvy</a> to manage the build VM.  It is similar to Vagrant in automating the grunt work of provisioning the VM.  The VM needs to have at least 4Gb RAM and 40Gb disk available in order to boot the seed Windows image.  This is an <tt class="docutils literal">n1.medium</tt> flavor on the private cloud I am using.</p>
<p>I am also using Ubuntu 14.04 because much of my tooling already assumes an Ubuntu build environment.  There is no technical reason that Fedora 20 could not be used, appropriate adjustments would need to be made, of course.</p>
<div class="section" id="build-vm">
<h2>Build VM</h2>
<p>I am not going to spend much time here explaining Cloudenvy's configuration, but there are two things required to not have a bad time with it.</p>
<p>Configure your cloud credentials in <tt class="docutils literal"><span class="pre">~/.cloudenvy</span></tt>:</p>
<pre class="literal-block">
cloudenvy:
    keypair_name: dev-key
    keypair_location: ~/.ssh/id_rsa-dev-key.pub
    clouds:
        cloud9:
            os_auth_url: https://cloud9.slackersatwork.com:2884/v2.0/
            os_tenant_name: demo
            os_username: demo
            os_password: secrete
</pre>
<pre class="literal-block">
project_config:
    name: imagebuilder
    image: Ubuntu 14.04
    remote_user: ubuntu
    flavor_name: n1.medium

sec_groups: [
    'tcp, 22, 22, 0.0.0.0/0',
    'tcp, 5900, 5919, 0.0.0.0/0',
    'icmp, -1, -1, 0.0.0.0/0'
]

files:
    Makefile: '~'
    ~/.cloud9.conf: '~'

provision_scripts:
    - install-prereqs.sh
</pre>
<p>The <tt class="docutils literal"><span class="pre">~/.cloud9.conf</span></tt> file is a simple script fragment that sets the <tt class="docutils literal">OS_*</tt> environment variable credentials required to authenticate using the OpenStack CLI tools.  It looks something like:</p>
<pre class="literal-block">
export OS_AUTH_URL=https://cloud9.slackersatwork.com:2884/v2.0/
export OS_TENANT_NAME=demo
export OS_USERNAME=demo
export OS_PASSWORD=secrete
</pre>
<p>Why do we need two sets of credentials?  Because we haven't taught Cloudenvy to read the usual environment variables yet.  I smell a pull request in my future...</p>
<p>Fire it up and log in:</p>
<pre class="literal-block">
envy up
envy ssh
</pre>
<p>At this point we can switch over to Flament's process.</p>
<p>Or we can use the cloudbase auto-answer template</p>
<p>Get the ISO:</p>
<pre class="literal-block">
&gt;en_windows_7_professional_with_sp1_x64_dvd_u_676939.iso
for i in aa ab ac ad ae af ag ah; do \
    swift download windows7 en_windows_7_professional_with_sp1_x64_dvd_u_676939.iso-$i; \
    cat en_windows_7_professional_with_sp1_x64_dvd_u_676939.iso-$i &gt;&gt;en_windows_7_professional_with_sp1_x64_dvd_u_676939.iso
done
</pre>
<p>sudo ./make-floppy.sh</p>
<hr class="docutils" />
<pre class="literal-block">
# add keypair if not already there
os keypair create --public-key ~/.ssh/id_rsa.pub $(hostname -s)

# Create VM
os server create \
  --image &quot;Ubuntu 14.04&quot; \
  --flavor n1.tiny \
  --key-name bunsen \
  --user-data cconfig.txt \
  --wait \
  dt-1

export IP=$(os server show dt-1 -f value -c addresses | cut -d '=' -f2)

# Go to there
ssh ubuntu&#64;$IP
</pre>
<hr class="docutils" />
<p>Now on to Florent's steps</p>
<ul>
<li><p class="first">Create a virtual disk</p>
<blockquote>
<p>qemu-img create -f qcow2 Windows-Server-2008-R2.qcow2 9G</p>
</blockquote>
</li>
<li><p class="first">Boot the install VM</p>
</li>
</ul>
<pre class="literal-block">
kvm \
    -m 2048 \
    -cdrom &lt;WINDOWS_INSTALLER_ISO&gt; \
    -drive file=Windows-Server-2008-R2.qcow2,if=virtio \
    -drive file=&lt;VIRTIO_DRIVERS_ISO&gt;,index=3,media=cdrom \
    -net nic,model=virtio \
    -net user \
    -nographic \
    -vnc :9 \
    -k fr \
    -usbdevice tablet
</pre>
<p>Connect via VNC to :9</p>
</div>
</div>
</div>
]]></content:encoded>
    </item>
  </channel>
</rss>

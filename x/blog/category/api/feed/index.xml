<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>HackStack Posts</title>
    <link>http://hackstack.org/x/blog</link>
    <description>OpenStack and other hackish things</description>
    <pubDate>Sat, 25 Oct 2014 01:45:41 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>OpenStack Low Level API</title>
      <link>http://hackstack.org/x/blog/2014/09/15/openstack-low-level-api</link>
      <pubDate>Mon, 15 Sep 2014 09:15:00 CDT</pubDate>
      <category><![CDATA[openstack]]></category>
      <category><![CDATA[api]]></category>
      <category><![CDATA[client]]></category>
      <guid isPermaLink="false">eIZng7kEM5KyvZSHnaO9Z1LG1s8=</guid>
      <description>OpenStack Low Level API</description>
      <content:encoded><![CDATA[<div class="document">
<p>The current Python library situation for OpenStack is, sorry to say, a mess.  Cleaning it up requires essentially starting over and abstracting the individual REST APIs to usable levels.  With OpenStackClient I started from the top and worked down to make the CLI a better experience.  I think we have proved that to be a worthwhile task.  Now it is time to start from the bottom and work up.</p>
<p>The existing libraries utilize a Manager/Resource model that may be suitable for application work, but every project's client repo was forked and changed so they are all similar but maddeningly different.  However, a good idea or two can be easily extracted and re-used in making things as simple as possible.</p>
<p>I originally started with no objects at all and went straight to top-level functions, as seen in the current <tt class="docutils literal">object.v1.lib</tt> APIs in OSC.  That required passing around the session and URLs required to complete the REST calls, which OSC already has available, but it is not a good general-purpose API.</p>
<p>I've been through a number of iterations of this and have settles on what is described here, a low-level API for OSC and other applications that do not require an object model.</p>
<div class="section" id="api-baseapi">
<h1>api.BaseAPI</h1>
<p>We start with a <a class="reference external" href="https://github.com/dtroyer/python-openstackclient/blob/low-level-api/openstackclient/api/api.py#L22">BaseAPI</a> object that contains the common operations.  It is pretty obvious there are only a couple of ways to get a list of resources from OpenStack APIs so the bulk of that and similar actions are here.</p>
<p>It is also very convenient to carry around a couple of other objects so they do not have to be passed in every call.  <a class="reference external" href="https://github.com/dtroyer/python-openstackclient/blob/low-level-api/openstackclient/api/api.py#L22">BaseAPI</a> contains a <tt class="docutils literal">session</tt>, <tt class="docutils literal">service type</tt> and <tt class="docutils literal">endpoint</tt> for each instance.  The <tt class="docutils literal">session</tt> is a <tt class="docutils literal">requests.session.Session</tt>-compatible object.  In this implementation we are using the <tt class="docutils literal">keystoneclient.session.Session</tt> which is close enough.  We use the ksc Session to take advantage of keystoneclient's authentication plugins.</p>
<p>The <tt class="docutils literal">service type</tt> and <tt class="docutils literal">endpoint</tt> attributes are specific to each API.  <tt class="docutils literal">service type</tt> is as it is used in the Service Catalog, i.e. <tt class="docutils literal">Compute</tt>, <tt class="docutils literal">Identity</tt>, etc.  <tt class="docutils literal">endpoint</tt> is the base URL extracted from the service catalog and is prepended to the passed URL strings in the <tt class="docutils literal">API</tt> method calls.</p>
<p>Most of the methods in <a class="reference external" href="https://github.com/dtroyer/python-openstackclient/blob/low-level-api/openstackclient/api/api.py#L22">BaseAPI</a> also are meant as foundational building blocks for the service APIs.  As such they have a pretty flexible list of arguments, many of them accepting a <tt class="docutils literal">session</tt> to override the base <tt class="docutils literal">session</tt>.  This layer is also where the JSON decoding takes place, these all return a Python <tt class="docutils literal">list</tt> or <tt class="docutils literal">dict</tt>.</p>
<p>The derived classes from <a class="reference external" href="https://github.com/dtroyer/python-openstackclient/blob/low-level-api/openstackclient/api/api.py#L22">BaseAPI</a> will contain all of the methods used to access their respective REST API.  Some of these will grow quite large...</p>
</div>
<div class="section" id="api-object-store-apiv1">
<h1>api.object_store.APIv1</h1>
<p>While this is a port of the existing code from OpenStackClient, <a class="reference external" href="https://github.com/dtroyer/python-openstackclient/blob/low-level-api/openstackclient/api/object_store.py#L26">object_store.APIv1</a> is still essentially a greenfield implementation of the <tt class="docutils literal"><span class="pre">Object-Store</span></tt> API.  All of the path manipulation, save for prepending the base URL, is done at this layer.</p>
</div>
<div class="section" id="api-compute-apiv2">
<h1>api.compute.APIv2</h1>
<p>This is one of the big ones.  At this point, only <tt class="docutils literal">flavor_list()</tt>, <tt class="docutils literal">flavor_show()</tt> and <tt class="docutils literal">key_list()</tt> have been implemented in <a class="reference external" href="https://github.com/dtroyer/python-openstackclient/blob/low-level-api/openstackclient/api/compute.py#L19">compute.APIv2</a>.</p>
<p>Unlike the <tt class="docutils literal"><span class="pre">object-store</span></tt> API, the rest of the OpenStack services return resources wrapped up in a top-level dict keyed with the base name of the resource.  This layer shall remove that wrapper so the returned values are all directly lists or dicts.  This removed the variations in server implementations where some wrap the list object individually and some wrap the entire list once.  Also, Keystone's tendency to insert an additional <tt class="docutils literal">values</tt> key into the return.</p>
</div>
<div class="section" id="api-identity-vx-apivx">
<h1>api.identity_vX.APIvX</h1>
<p>The naming of <a class="reference external" href="https://github.com/dtroyer/python-openstackclient/blob/low-level-api/openstackclient/api/identity_v2.py#L19">identity_v2.APIv2</a> and <a class="reference external" href="https://github.com/dtroyer/python-openstackclient/blob/low-level-api/openstackclient/api/identity_v3.py#L19">identity_v3.APIv3</a> is a bit repetitive but putting the version into the module name lets us break down the already-long files.</p>
<p>At this point, only <tt class="docutils literal">project_list()</tt> is implemented in an effort to work out the mechanics of supporting multiple API versions.  In OSC, this is already handled in the ClientManager and individual client classes so there is not much to see here.  It may be different otherwise.</p>
</div>
<div class="section" id="osc-usage">
<h1>OSC Usage</h1>
<p>To demonstrate how this API is used, I've added an <a class="reference external" href="https://github.com/dtroyer/python-openstackclient/blob/low-level-api/openstackclient/api/api.py#L22">BaseAPI</a> instance to the existing client objects that get stored in the <tt class="docutils literal">ClientManager</tt>.  For example, the addition for <a class="reference external" href="https://github.com/dtroyer/python-openstackclient/commit/2bfc9e1b722cb89670ba4878f10fb07d9c68519f#diff-9d500da5511aec08e46397bc7a4b25bdR75">compute.client</a> is one object instantiation and an import.  Now in OSC, <tt class="docutils literal">clientmanager.compute.api</tt> has all of the (implemented) <tt class="docutils literal">Compute</tt> API methods.</p>
<p>Using it in the flavor commands is a <a class="reference external" href="https://github.com/dtroyer/python-openstackclient/commit/2bfc9e1b722cb89670ba4878f10fb07d9c68519f#diff-1be98e03ae4586b73d8ad5f62f0dc578L163">simple change</a> to call <tt class="docutils literal">compute.api</tt> methods rather than the <tt class="docutils literal">compute.flavor.XXX</tt> methods.</p>
<p>Setting up for multiple API versions took a bit more work, as shown in <a class="reference external" href="https://github.com/dtroyer/python-openstackclient/commit/2bfc9e1b722cb89670ba4878f10fb07d9c68519f#diff-f7023c81f38d2c70e77da533164db4b6L31">identity.client</a>.  A parallel construction to the client class lookup is required, and would totally replace the existing version lookup once the old client is no longer required.</p>
</div>
<div class="section" id="fluff">
<h1>Fluff</h1>
<p>One other cool feature is utilizing <tt class="docutils literal">requests_mock</tt> for testing from the start.  It works great and has not the problems that rode along with <tt class="docutils literal">httpretty</tt>.</p>
</div>
<div class="section" id="now-what">
<h1>Now What?</h1>
<p>Many object models could be built on top of this API design.  The <tt class="docutils literal">API</tt> object hierarchy harkens back to the original client lib <tt class="docutils literal">Manager</tt> classes, except that they encompass an entire REST API and not one for each resource type.</p>
</div>
<div class="section" id="but-you-said-sanity-earlier">
<h1>But You Said 'Sanity' Earlier!</h1>
<p>Sanity in terms of coalescing the distinct APIs into something a bit more common?  Yes.  However, this isn't going to fix everything, just some of the little things that application developers really shouldn't have to worry about.  I want the project REST API docs to be usable, with maybe a couple of notes for the differences.</p>
<p>For example, OSC and this implementation both use the word <tt class="docutils literal">project</tt> in place of <tt class="docutils literal">tenant</tt>.  Everywhere.  Even where the underlying API uses <tt class="docutils literal">tenant</tt>.  This is an easy change for a developer to remember.  I think.</p>
<p>Also, smoothing out the returned data structures to not include the resource wrappers is an easy one.</p>
</div>
<div class="section" id="duplicating-work">
<h1>Duplicating Work?</h1>
<p>&quot;Doesn't this duplicate what is already being done in the OpenStack Python SDK?&quot;</p>
<p>Really, no.  This is meant to be the low-level SDK API that the Resource model can utilize to provide the back-end to its object model.  Honestly, most applications are going to want to use the Resource model, or an even higher API that makes easy things really easy, and hard things not-so-hard, as long as you buy in to the assumptions baked in to the implementation.</p>
<p>Sort of like OS/X or iOS.  Simple to use, as long as you don't want to anything different.  Maybe we should call that top-most API <tt class="docutils literal">iOSAPI</tt>?</p>
</div>
</div>
]]></content:encoded>
    </item>
  </channel>
</rss>
